// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: suffuse/v1/suffuse.proto

package suffusev1

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ClipboardItem carries a single MIME representation of clipboard content.
// data is raw bytes; the JSON gateway automatically base64-encodes this field.
type ClipboardItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mime          string                 `protobuf:"bytes,1,opt,name=mime,proto3" json:"mime,omitempty"`
	Data          []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClipboardItem) Reset() {
	*x = ClipboardItem{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClipboardItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClipboardItem) ProtoMessage() {}

func (x *ClipboardItem) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClipboardItem.ProtoReflect.Descriptor instead.
func (*ClipboardItem) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{0}
}

func (x *ClipboardItem) GetMime() string {
	if x != nil {
		return x.Mime
	}
	return ""
}

func (x *ClipboardItem) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type CopyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// clipboard identifies the named clipboard (empty â†’ "default").
	Clipboard string `protobuf:"bytes,1,opt,name=clipboard,proto3" json:"clipboard,omitempty"`
	// source is a human-readable label for the originating host.
	Source        string           `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Items         []*ClipboardItem `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CopyRequest) Reset() {
	*x = CopyRequest{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyRequest) ProtoMessage() {}

func (x *CopyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyRequest.ProtoReflect.Descriptor instead.
func (*CopyRequest) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{1}
}

func (x *CopyRequest) GetClipboard() string {
	if x != nil {
		return x.Clipboard
	}
	return ""
}

func (x *CopyRequest) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *CopyRequest) GetItems() []*ClipboardItem {
	if x != nil {
		return x.Items
	}
	return nil
}

type CopyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CopyResponse) Reset() {
	*x = CopyResponse{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyResponse) ProtoMessage() {}

func (x *CopyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyResponse.ProtoReflect.Descriptor instead.
func (*CopyResponse) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{2}
}

type PasteRequest struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Clipboard string                 `protobuf:"bytes,1,opt,name=clipboard,proto3" json:"clipboard,omitempty"`
	// accepts is an optional MIME filter (empty = return all types).
	Accepts       []string `protobuf:"bytes,2,rep,name=accepts,proto3" json:"accepts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PasteRequest) Reset() {
	*x = PasteRequest{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PasteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PasteRequest) ProtoMessage() {}

func (x *PasteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PasteRequest.ProtoReflect.Descriptor instead.
func (*PasteRequest) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{3}
}

func (x *PasteRequest) GetClipboard() string {
	if x != nil {
		return x.Clipboard
	}
	return ""
}

func (x *PasteRequest) GetAccepts() []string {
	if x != nil {
		return x.Accepts
	}
	return nil
}

type PasteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Source        string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Clipboard     string                 `protobuf:"bytes,2,opt,name=clipboard,proto3" json:"clipboard,omitempty"`
	Items         []*ClipboardItem       `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PasteResponse) Reset() {
	*x = PasteResponse{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PasteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PasteResponse) ProtoMessage() {}

func (x *PasteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PasteResponse.ProtoReflect.Descriptor instead.
func (*PasteResponse) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{4}
}

func (x *PasteResponse) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *PasteResponse) GetClipboard() string {
	if x != nil {
		return x.Clipboard
	}
	return ""
}

func (x *PasteResponse) GetItems() []*ClipboardItem {
	if x != nil {
		return x.Items
	}
	return nil
}

type WatchRequest struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Clipboard string                 `protobuf:"bytes,1,opt,name=clipboard,proto3" json:"clipboard,omitempty"`
	// accepts restricts which MIME types the server will send (empty = all).
	// Example: ["text/plain"] lets a Neovim plugin ignore images server-side.
	Accepts []string `protobuf:"bytes,2,rep,name=accepts,proto3" json:"accepts,omitempty"`
	// metadata_only: if true, items is omitted from WatchResponse and the
	// client should call Paste to retrieve content on demand.
	MetadataOnly  bool `protobuf:"varint,3,opt,name=metadata_only,json=metadataOnly,proto3" json:"metadata_only,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WatchRequest) Reset() {
	*x = WatchRequest{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchRequest) ProtoMessage() {}

func (x *WatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchRequest.ProtoReflect.Descriptor instead.
func (*WatchRequest) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{5}
}

func (x *WatchRequest) GetClipboard() string {
	if x != nil {
		return x.Clipboard
	}
	return ""
}

func (x *WatchRequest) GetAccepts() []string {
	if x != nil {
		return x.Accepts
	}
	return nil
}

func (x *WatchRequest) GetMetadataOnly() bool {
	if x != nil {
		return x.MetadataOnly
	}
	return false
}

// WatchResponse is delivered to Watch subscribers whenever the clipboard
// changes.
type WatchResponse struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Source    string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Clipboard string                 `protobuf:"bytes,2,opt,name=clipboard,proto3" json:"clipboard,omitempty"`
	// items is empty when metadata_only was set in WatchRequest.
	Items []*ClipboardItem `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
	// available_types is always populated so metadata-only clients know what
	// representations are available before calling Paste.
	AvailableTypes []string `protobuf:"bytes,4,rep,name=available_types,json=availableTypes,proto3" json:"available_types,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WatchResponse) Reset() {
	*x = WatchResponse{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchResponse) ProtoMessage() {}

func (x *WatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchResponse.ProtoReflect.Descriptor instead.
func (*WatchResponse) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{6}
}

func (x *WatchResponse) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *WatchResponse) GetClipboard() string {
	if x != nil {
		return x.Clipboard
	}
	return ""
}

func (x *WatchResponse) GetItems() []*ClipboardItem {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *WatchResponse) GetAvailableTypes() []string {
	if x != nil {
		return x.AvailableTypes
	}
	return nil
}

type StatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusRequest) Reset() {
	*x = StatusRequest{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusRequest) ProtoMessage() {}

func (x *StatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusRequest.ProtoReflect.Descriptor instead.
func (*StatusRequest) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{7}
}

// PeerInfo describes a single connected peer.
type PeerInfo struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Source string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Addr   string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	// role is one of "client", "upstream", or "both" (server with local clipboard).
	Role          string                 `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	Clipboard     string                 `protobuf:"bytes,4,opt,name=clipboard,proto3" json:"clipboard,omitempty"`
	AcceptedTypes []string               `protobuf:"bytes,5,rep,name=accepted_types,json=acceptedTypes,proto3" json:"accepted_types,omitempty"`
	ConnectedAt   *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=connected_at,json=connectedAt,proto3" json:"connected_at,omitempty"`
	LastSeen      *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PeerInfo) Reset() {
	*x = PeerInfo{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerInfo) ProtoMessage() {}

func (x *PeerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerInfo.ProtoReflect.Descriptor instead.
func (*PeerInfo) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{8}
}

func (x *PeerInfo) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *PeerInfo) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *PeerInfo) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *PeerInfo) GetClipboard() string {
	if x != nil {
		return x.Clipboard
	}
	return ""
}

func (x *PeerInfo) GetAcceptedTypes() []string {
	if x != nil {
		return x.AcceptedTypes
	}
	return nil
}

func (x *PeerInfo) GetConnectedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ConnectedAt
	}
	return nil
}

func (x *PeerInfo) GetLastSeen() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSeen
	}
	return nil
}

type StatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Peers []*PeerInfo            `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
	// upstream_info is populated when this server is federated to an upstream.
	// Absent on standalone servers.
	UpstreamInfo  *UpstreamInfo `protobuf:"bytes,2,opt,name=upstream_info,json=upstreamInfo,proto3" json:"upstream_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusResponse) Reset() {
	*x = StatusResponse{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusResponse) ProtoMessage() {}

func (x *StatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{9}
}

func (x *StatusResponse) GetPeers() []*PeerInfo {
	if x != nil {
		return x.Peers
	}
	return nil
}

func (x *StatusResponse) GetUpstreamInfo() *UpstreamInfo {
	if x != nil {
		return x.UpstreamInfo
	}
	return nil
}

// UpstreamInfo carries federation connection metadata, allowing CLI tools to
// display upstream server and connection state in status output.
type UpstreamInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Addr          string                 `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Source        string                 `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	ConnectedAt   *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=connected_at,json=connectedAt,proto3" json:"connected_at,omitempty"`
	LastSeen      *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamInfo) Reset() {
	*x = UpstreamInfo{}
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamInfo) ProtoMessage() {}

func (x *UpstreamInfo) ProtoReflect() protoreflect.Message {
	mi := &file_suffuse_v1_suffuse_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpstreamInfo.ProtoReflect.Descriptor instead.
func (*UpstreamInfo) Descriptor() ([]byte, []int) {
	return file_suffuse_v1_suffuse_proto_rawDescGZIP(), []int{10}
}

func (x *UpstreamInfo) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *UpstreamInfo) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *UpstreamInfo) GetConnectedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ConnectedAt
	}
	return nil
}

func (x *UpstreamInfo) GetLastSeen() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSeen
	}
	return nil
}

var File_suffuse_v1_suffuse_proto protoreflect.FileDescriptor

const file_suffuse_v1_suffuse_proto_rawDesc = "" +
	"\n" +
	"\x18suffuse/v1/suffuse.proto\x12\n" +
	"suffuse.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"7\n" +
	"\rClipboardItem\x12\x12\n" +
	"\x04mime\x18\x01 \x01(\tR\x04mime\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"t\n" +
	"\vCopyRequest\x12\x1c\n" +
	"\tclipboard\x18\x01 \x01(\tR\tclipboard\x12\x16\n" +
	"\x06source\x18\x02 \x01(\tR\x06source\x12/\n" +
	"\x05items\x18\x03 \x03(\v2\x19.suffuse.v1.ClipboardItemR\x05items\"\x0e\n" +
	"\fCopyResponse\"F\n" +
	"\fPasteRequest\x12\x1c\n" +
	"\tclipboard\x18\x01 \x01(\tR\tclipboard\x12\x18\n" +
	"\aaccepts\x18\x02 \x03(\tR\aaccepts\"v\n" +
	"\rPasteResponse\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x1c\n" +
	"\tclipboard\x18\x02 \x01(\tR\tclipboard\x12/\n" +
	"\x05items\x18\x03 \x03(\v2\x19.suffuse.v1.ClipboardItemR\x05items\"k\n" +
	"\fWatchRequest\x12\x1c\n" +
	"\tclipboard\x18\x01 \x01(\tR\tclipboard\x12\x18\n" +
	"\aaccepts\x18\x02 \x03(\tR\aaccepts\x12#\n" +
	"\rmetadata_only\x18\x03 \x01(\bR\fmetadataOnly\"\x9f\x01\n" +
	"\rWatchResponse\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x1c\n" +
	"\tclipboard\x18\x02 \x01(\tR\tclipboard\x12/\n" +
	"\x05items\x18\x03 \x03(\v2\x19.suffuse.v1.ClipboardItemR\x05items\x12'\n" +
	"\x0favailable_types\x18\x04 \x03(\tR\x0eavailableTypes\"\x0f\n" +
	"\rStatusRequest\"\x87\x02\n" +
	"\bPeerInfo\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x12\n" +
	"\x04addr\x18\x02 \x01(\tR\x04addr\x12\x12\n" +
	"\x04role\x18\x03 \x01(\tR\x04role\x12\x1c\n" +
	"\tclipboard\x18\x04 \x01(\tR\tclipboard\x12%\n" +
	"\x0eaccepted_types\x18\x05 \x03(\tR\racceptedTypes\x12=\n" +
	"\fconnected_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\vconnectedAt\x127\n" +
	"\tlast_seen\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\blastSeen\"{\n" +
	"\x0eStatusResponse\x12*\n" +
	"\x05peers\x18\x01 \x03(\v2\x14.suffuse.v1.PeerInfoR\x05peers\x12=\n" +
	"\rupstream_info\x18\x02 \x01(\v2\x18.suffuse.v1.UpstreamInfoR\fupstreamInfo\"\xb2\x01\n" +
	"\fUpstreamInfo\x12\x12\n" +
	"\x04addr\x18\x01 \x01(\tR\x04addr\x12\x16\n" +
	"\x06source\x18\x02 \x01(\tR\x06source\x12=\n" +
	"\fconnected_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\vconnectedAt\x127\n" +
	"\tlast_seen\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\blastSeen2\xde\x02\n" +
	"\x10ClipboardService\x12N\n" +
	"\x04Copy\x12\x17.suffuse.v1.CopyRequest\x1a\x18.suffuse.v1.CopyResponse\"\x13\x82\xd3\xe4\x93\x02\r:\x01*\"\b/v1/copy\x12R\n" +
	"\x05Paste\x12\x18.suffuse.v1.PasteRequest\x1a\x19.suffuse.v1.PasteResponse\"\x14\x82\xd3\xe4\x93\x02\x0e:\x01*\"\t/v1/paste\x12Q\n" +
	"\x05Watch\x12\x18.suffuse.v1.WatchRequest\x1a\x19.suffuse.v1.WatchResponse\"\x11\x82\xd3\xe4\x93\x02\v\x12\t/v1/watch0\x01\x12S\n" +
	"\x06Status\x12\x19.suffuse.v1.StatusRequest\x1a\x1a.suffuse.v1.StatusResponse\"\x12\x82\xd3\xe4\x93\x02\f\x12\n" +
	"/v1/statusB-Z+go.klb.dev/suffuse/gen/suffuse/v1;suffusev1b\x06proto3"

var (
	file_suffuse_v1_suffuse_proto_rawDescOnce sync.Once
	file_suffuse_v1_suffuse_proto_rawDescData []byte
)

func file_suffuse_v1_suffuse_proto_rawDescGZIP() []byte {
	file_suffuse_v1_suffuse_proto_rawDescOnce.Do(func() {
		file_suffuse_v1_suffuse_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_suffuse_v1_suffuse_proto_rawDesc), len(file_suffuse_v1_suffuse_proto_rawDesc)))
	})
	return file_suffuse_v1_suffuse_proto_rawDescData
}

var file_suffuse_v1_suffuse_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_suffuse_v1_suffuse_proto_goTypes = []any{
	(*ClipboardItem)(nil),         // 0: suffuse.v1.ClipboardItem
	(*CopyRequest)(nil),           // 1: suffuse.v1.CopyRequest
	(*CopyResponse)(nil),          // 2: suffuse.v1.CopyResponse
	(*PasteRequest)(nil),          // 3: suffuse.v1.PasteRequest
	(*PasteResponse)(nil),         // 4: suffuse.v1.PasteResponse
	(*WatchRequest)(nil),          // 5: suffuse.v1.WatchRequest
	(*WatchResponse)(nil),         // 6: suffuse.v1.WatchResponse
	(*StatusRequest)(nil),         // 7: suffuse.v1.StatusRequest
	(*PeerInfo)(nil),              // 8: suffuse.v1.PeerInfo
	(*StatusResponse)(nil),        // 9: suffuse.v1.StatusResponse
	(*UpstreamInfo)(nil),          // 10: suffuse.v1.UpstreamInfo
	(*timestamppb.Timestamp)(nil), // 11: google.protobuf.Timestamp
}
var file_suffuse_v1_suffuse_proto_depIdxs = []int32{
	0,  // 0: suffuse.v1.CopyRequest.items:type_name -> suffuse.v1.ClipboardItem
	0,  // 1: suffuse.v1.PasteResponse.items:type_name -> suffuse.v1.ClipboardItem
	0,  // 2: suffuse.v1.WatchResponse.items:type_name -> suffuse.v1.ClipboardItem
	11, // 3: suffuse.v1.PeerInfo.connected_at:type_name -> google.protobuf.Timestamp
	11, // 4: suffuse.v1.PeerInfo.last_seen:type_name -> google.protobuf.Timestamp
	8,  // 5: suffuse.v1.StatusResponse.peers:type_name -> suffuse.v1.PeerInfo
	10, // 6: suffuse.v1.StatusResponse.upstream_info:type_name -> suffuse.v1.UpstreamInfo
	11, // 7: suffuse.v1.UpstreamInfo.connected_at:type_name -> google.protobuf.Timestamp
	11, // 8: suffuse.v1.UpstreamInfo.last_seen:type_name -> google.protobuf.Timestamp
	1,  // 9: suffuse.v1.ClipboardService.Copy:input_type -> suffuse.v1.CopyRequest
	3,  // 10: suffuse.v1.ClipboardService.Paste:input_type -> suffuse.v1.PasteRequest
	5,  // 11: suffuse.v1.ClipboardService.Watch:input_type -> suffuse.v1.WatchRequest
	7,  // 12: suffuse.v1.ClipboardService.Status:input_type -> suffuse.v1.StatusRequest
	2,  // 13: suffuse.v1.ClipboardService.Copy:output_type -> suffuse.v1.CopyResponse
	4,  // 14: suffuse.v1.ClipboardService.Paste:output_type -> suffuse.v1.PasteResponse
	6,  // 15: suffuse.v1.ClipboardService.Watch:output_type -> suffuse.v1.WatchResponse
	9,  // 16: suffuse.v1.ClipboardService.Status:output_type -> suffuse.v1.StatusResponse
	13, // [13:17] is the sub-list for method output_type
	9,  // [9:13] is the sub-list for method input_type
	9,  // [9:9] is the sub-list for extension type_name
	9,  // [9:9] is the sub-list for extension extendee
	0,  // [0:9] is the sub-list for field type_name
}

func init() { file_suffuse_v1_suffuse_proto_init() }
func file_suffuse_v1_suffuse_proto_init() {
	if File_suffuse_v1_suffuse_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_suffuse_v1_suffuse_proto_rawDesc), len(file_suffuse_v1_suffuse_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_suffuse_v1_suffuse_proto_goTypes,
		DependencyIndexes: file_suffuse_v1_suffuse_proto_depIdxs,
		MessageInfos:      file_suffuse_v1_suffuse_proto_msgTypes,
	}.Build()
	File_suffuse_v1_suffuse_proto = out.File
	file_suffuse_v1_suffuse_proto_goTypes = nil
	file_suffuse_v1_suffuse_proto_depIdxs = nil
}
